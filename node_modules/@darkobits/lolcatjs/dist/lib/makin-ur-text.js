"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _readline = _interopRequireDefault(require("readline"));

var _adeiu = _interopRequireDefault(require("@darkobits/adeiu"));

var _sleep = _interopRequireDefault(require("@darkobits/sleep"));

var _ansi = _interopRequireDefault(require("ansi"));

var _asyncLock = _interopRequireDefault(require("async-lock"));

var _chalk = _interopRequireDefault(require("chalk"));

var _ow = _interopRequireDefault(require("ow"));

var _pStream = _interopRequireDefault(require("p-stream"));

var _split = _interopRequireDefault(require("split2"));

var _stripColor = _interopRequireDefault(require("strip-color"));

var _through = _interopRequireDefault(require("through"));

var _yargs = _interopRequireDefault(require("yargs"));

var _constantz = require("../etc/constantz");

var _randomTingz = require("./random-tingz");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MakinUrText {
  constructor({
    seed,
    freq,
    spread,
    animate,
    speed,
    duration,
    force
  } = {}) {
    _defineProperty(this, "_muhChalk", void 0);

    _defineProperty(this, "_cursorz", void 0);

    _defineProperty(this, "_freq", void 0);

    _defineProperty(this, "_spread", void 0);

    _defineProperty(this, "_animate", void 0);

    _defineProperty(this, "_speed", void 0);

    _defineProperty(this, "_duration", void 0);

    _defineProperty(this, "_wait4Turn", void 0);

    _defineProperty(this, "_seed", void 0);

    _defineProperty(this, "_loltext", void 0);

    _defineProperty(this, "stream", void 0);

    this._loltext = '';
    this._cursorz = [];
    this._wait4Turn = new _asyncLock.default();
    this.stream = this.makeStreamPlz();

    if (seed) {
      (0, _ow.default)(seed, 'seed', _ow.default.number.positive);
      this._seed = seed;
    } else {
      this._seed = (0, _randomTingz.randyNumPlz)(_constantz.none, 256);
    }

    if (freq) {
      (0, _ow.default)(freq, 'freq', _ow.default.number);
      this._freq = freq;
    } else {
      this._freq = _constantz.TEH_DEFAULT_OPSHUNZ.freq;
    }

    if (spread) {
      (0, _ow.default)(spread, 'spread', _ow.default.number);
      this._spread = spread;
    } else {
      this._spread = _constantz.TEH_DEFAULT_OPSHUNZ.spread;
    }

    this._animate = Boolean(animate);

    if (this._animate) {
      (0, _adeiu.default)(() => {
        this.yesCursor();
        process.exit(_constantz.none);
      });
    }

    if (speed) {
      (0, _ow.default)(speed, 'speed', _ow.default.number);
      this._speed = speed;
    } else {
      this._speed = _constantz.TEH_DEFAULT_OPSHUNZ.speed;
    }

    if (duration) {
      (0, _ow.default)(duration, 'duration', _ow.default.number);
      this._duration = duration;
    } else {
      this._duration = _constantz.TEH_DEFAULT_OPSHUNZ.duration;
    }

    this._muhChalk = new _chalk.default.constructor(force ? {
      enabled: _constantz.definitely,
      level: _constantz.none + 2
    } : undefined);
  }

  makeStreamPlz() {
    function writeDis(data) {
      this.emit('data', data);
    }

    const pipe = wrappedPipe => {
      return (destStream, opts) => {
        this._cursorz.push((0, _ansi.default)(destStream));

        return wrappedPipe(destStream, opts);
      };
    };

    const anStream = (0, _through.default)(writeDis);
    anStream.pipe = pipe(anStream.pipe.bind(anStream));
    return anStream;
  }

  yesCursor() {
    this._cursorz.forEach(cursor => {
      cursor.show();
    });
  }

  noCursor() {
    this._cursorz.forEach(cursor => {
      cursor.hide();
    });
  }

  colorizeUrLine(line) {
    return (0, _stripColor.default)(line).split('').map((char, index) => {
      const {
        red,
        green,
        blue
      } = (0, _randomTingz.makeItRainbow)(this._freq, this._seed + index / this._spread);
      return this._muhChalk.rgb(red, green, blue)(char);
    }).join('');
  }

  async animateUrLine(urLine) {
    return this._wait4Turn.acquire('meow', async () => {
      const seed = this._seed;

      for (let i = 1; i < this._duration; i++) {
        this.noCursor();

        _readline.default.cursorTo(this.stream, _constantz.none);

        this._seed += this._spread;

        if (i % 2 === _constantz.none) {
          const urColorizedLine = this.colorizeUrLine(urLine.substr(_constantz.none, _yargs.default.terminalWidth()));
          this.stream.write(urColorizedLine);
        }

        await (0, _sleep.default)(1 / this._speed * (_constantz.none + 1000));
      }

      this._seed = seed;
      this.yesCursor();
    });
  }

  async makeLine(line) {
    this._seed += 0.33;

    if (this._animate) {
      await this.animateUrLine(line);
    }

    const colorizedLine = this.colorizeUrLine(line) + '\n';
    this._loltext += colorizedLine;
    this.stream.write(colorizedLine);
  }

  fromString(urString = '') {
    urString.split('\n').forEach(async urLien => {
      await this.makeLine(urLien);
    });
  }

  async fromStream(urStream) {
    return new Promise(async (keep, noKeep) => {
      const urStreamWasTakingTooLong = setTimeout(() => {
        noKeep(new Error('Stream timeout; did not receive any data.'));
      }, 250);
      urStream.resume();
      urStream.setEncoding('utf8');
      urStream.pipe((0, _split.default)()).on('data', async tehLine => {
        clearTimeout(urStreamWasTakingTooLong);
        await this.makeLine(tehLine);
      });
      await (0, _pStream.default)(urStream);
      keep();
    });
  }

  async fromFile(urFile) {
    const theFileStream = _fs.default.createReadStream(urFile).pipe((0, _split.default)());

    theFileStream.setEncoding('utf8');
    theFileStream.on('data', async tehLine => {
      await this.makeLine(tehLine);
    });
    await (0, _pStream.default)(theFileStream);
  }

  toString() {
    return this._loltext.trim();
  }

  static fromString(urString, urOpshunz) {
    const urLoltext = new MakinUrText(urOpshunz);
    urString.split('\n').forEach(line => {
      urLoltext._seed += 0.33;
      const colorizedLine = urLoltext.colorizeUrLine(line) + '\n';
      urLoltext._loltext += colorizedLine;
      urLoltext.stream.write(colorizedLine);
    });
    return urLoltext.toString();
  }

}

exports.default = MakinUrText;
//# sourceMappingURL=makin-ur-text.js.map